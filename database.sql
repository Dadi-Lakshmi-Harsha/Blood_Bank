--schema--
-- This script was generated by the ERD tool in pgAdmin 4.
-- Please log an issue at https://github.com/pgadmin-org/pgadmin4/issues/new/choose if you find any bugs, including reproduction steps.

--not everything is directly given by pg admin some of them was implemented by admin so takecare of commas after querries they might throw error

BEGIN;


CREATE TABLE IF NOT EXISTS public.camp
(
    camp_id serial NOT NULL,
    city_id integer NOT NULL,
    start_date date NOT NULL,
    end_date date NOT NULL,
    CONSTRAINT camp_pkey PRIMARY KEY (camp_id)
);

CREATE TABLE IF NOT EXISTS public.city
(
    city_id serial NOT NULL,
    name character varying(100) COLLATE pg_catalog."default" NOT NULL,
    location point NOT NULL,
    CONSTRAINT city_pkey PRIMARY KEY (city_id)
);

CREATE TABLE IF NOT EXISTS public.donates
(
    user_id integer NOT NULL,
    blood_id integer NOT NULL,
    donation_date date NOT NULL,
    CONSTRAINT donates_pkey PRIMARY KEY (user_id, blood_id)
);

CREATE TABLE IF NOT EXISTS public.employees
(
    employee_id serial NOT NULL,
    role character varying(50) COLLATE pg_catalog."default" NOT NULL,
    user_id integer NOT NULL,
    salary numeric NOT NULL,
    CONSTRAINT employees_pkey PRIMARY KEY (employee_id),
    CONSTRAINT employees_user_id_key UNIQUE (user_id)
);

CREATE TABLE IF NOT EXISTS public.inventory
(
    blood_id serial NOT NULL,
    camp_id integer NOT NULL,
    blood_type character varying(3) COLLATE pg_catalog."default" NOT NULL,
    expiry_date date NOT NULL,
    assigned character varying(3) COLLATE pg_catalog."default" DEFAULT 'no'::character varying,
    CONSTRAINT inventory_pkey PRIMARY KEY (blood_id)
);

CREATE TABLE IF NOT EXISTS public.request_status
(
    process_id serial NOT NULL,
    request_id integer NOT NULL,
    blood_id integer,
    status character varying(20) COLLATE pg_catalog."default" NOT NULL DEFAULT 'no'::character varying,
    date_approved date,
    blood_found character varying(3) COLLATE pg_catalog."default" DEFAULT 'no'::character varying,
    CONSTRAINT request_status_pkey PRIMARY KEY (process_id)
);

CREATE TABLE IF NOT EXISTS public.requests
(
    request_id serial NOT NULL,
    user_id integer NOT NULL,
    employee_id integer NOT NULL,
    units_required integer NOT NULL DEFAULT 0,
    blood_type character varying(10) COLLATE pg_catalog."default" NOT NULL,
    request_date date NOT NULL DEFAULT CURRENT_DATE,
    CONSTRAINT requests_pkey PRIMARY KEY (request_id)
);

CREATE TABLE IF NOT EXISTS public.users
(
    user_id serial NOT NULL,
    password_hash character varying(255) COLLATE pg_catalog."default" NOT NULL,
    blood_type character varying(10) COLLATE pg_catalog."default" NOT NULL,
    name character varying(100) COLLATE pg_catalog."default" NOT NULL,
    city_id integer NOT NULL,
    dob date NOT NULL,
    contact text COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT users_pkey PRIMARY KEY (user_id)
);

CREATE TABLE IF NOT EXISTS public.v_last_donation
(
    max date
);

ALTER TABLE IF EXISTS public.camp
    ADD CONSTRAINT camp_city_id_fkey FOREIGN KEY (city_id)
    REFERENCES public.city (city_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.donates
    ADD CONSTRAINT donates_blood_id_fkey FOREIGN KEY (blood_id)
    REFERENCES public.inventory (blood_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION
    DEFERRABLE INITIALLY DEFERRED;


ALTER TABLE IF EXISTS public.donates
    ADD CONSTRAINT donates_user_id_fkey FOREIGN KEY (user_id)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.employees
    ADD CONSTRAINT employees_user_id_fkey FOREIGN KEY (user_id)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;
CREATE INDEX IF NOT EXISTS employees_user_id_key
    ON public.employees(user_id);


ALTER TABLE IF EXISTS public.inventory
    ADD CONSTRAINT inventory_camp_id_fkey FOREIGN KEY (camp_id)
    REFERENCES public.camp (camp_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.request_status
    ADD CONSTRAINT request_status_blood_id_fkey FOREIGN KEY (blood_id)
    REFERENCES public.inventory (blood_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.request_status
    ADD CONSTRAINT request_status_request_id_fkey FOREIGN KEY (request_id)
    REFERENCES public.requests (request_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.requests
    ADD CONSTRAINT requests_employee_id_fkey FOREIGN KEY (employee_id)
    REFERENCES public.employees (employee_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.requests
    ADD CONSTRAINT requests_user_id_fkey FOREIGN KEY (user_id)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.users
    ADD CONSTRAINT users_city_id_fkey FOREIGN KEY (city_id)
    REFERENCES public.city (city_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;

END;

-- This script was generated by the ERD tool in pgAdmin 4.
--functions--
--this is the trigger when a new blood sample is entered in the inventory then it searches for pending requests from request status and finds for matching and 
--assigns it and pops message for camp coordinator for approval--

CREATE OR REPLACE FUNCTION match_blood_to_request() RETURNS TRIGGER AS $$
DECLARE
    v_request_id INT;
    v_process_id INT;
    v_city_id INT;
BEGIN
    -- Only proceed if assigned is 'no'
    IF NEW.assigned = 'no' THEN
        -- Get city_id from camp
        SELECT city_id INTO v_city_id
        FROM camp
        WHERE camp_id = NEW.camp_id;

        -- Find a matching pending request
        SELECT r.request_id, rs.process_id INTO v_request_id, v_process_id
        FROM requests r
        JOIN request_status rs ON r.request_id = rs.request_id
        JOIN users u ON r.user_id = u.user_id
        WHERE r.blood_type = NEW.blood_type
        AND u.city_id = v_city_id
        AND rs.status = 'no'
        AND rs.blood_found = 'no'
        AND rs.blood_id IS NULL
        ORDER BY r.request_date
        LIMIT 1;

        -- Assign blood to request if found
        IF v_request_id IS NOT NULL THEN
            UPDATE inventory
            SET assigned = 'yes'
            WHERE blood_id = NEW.blood_id;

            UPDATE request_status
            SET blood_id = NEW.blood_id,
                blood_found = 'yes'
            WHERE process_id = v_process_id;
        END IF;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS inventory_trigger ON inventory;
CREATE TRIGGER inventory_trigger
AFTER INSERT OR UPDATE OF assigned ON inventory
FOR EACH ROW
WHEN (NEW.assigned = 'no')
EXECUTE FUNCTION match_blood_to_request();
--	If is an insert is done in request it triggers to insert in request status and
-- also check for inventory for matching blood and updates the record as assigned or no

CREATE OR REPLACE FUNCTION handle_new_request() RETURNS TRIGGER AS $$
DECLARE
    v_city_id INT;
    v_blood_id INT;
    v_process_id INT;
BEGIN
    -- Get user's city_id
    SELECT city_id INTO v_city_id
    FROM users
    WHERE user_id = NEW.user_id;

    -- Insert into request_status with default values
    INSERT INTO request_status (request_id, status, blood_found)
    VALUES (NEW.request_id, 'no', 'no')
    RETURNING process_id INTO v_process_id;

    -- Find a matching unassigned blood unit in inventory
    SELECT i.blood_id INTO v_blood_id
    FROM inventory i
    JOIN camp c ON i.camp_id = c.camp_id
    WHERE i.blood_type = NEW.blood_type
    AND i.assigned = 'no'
    AND i.expiry_date > CURRENT_DATE
    AND c.city_id = v_city_id
    ORDER BY i.expiry_date ASC
    LIMIT 1;

    -- If a match is found, assign the blood
    IF v_blood_id IS NOT NULL THEN
        UPDATE inventory
        SET assigned = 'yes'
        WHERE blood_id = v_blood_id;

        UPDATE request_status
        SET blood_id = v_blood_id,
            blood_found = 'yes'
        WHERE process_id = v_process_id;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS request_trigger ON requests;
CREATE TRIGGER request_trigger
AFTER INSERT ON requests
FOR EACH ROW
EXECUTE FUNCTION handle_new_request();

-- trigger for donation

CREATE OR REPLACE FUNCTION handle_donation_inventory() RETURNS TRIGGER AS $$
DECLARE
    v_blood_type VARCHAR;
    v_city_id INT;
    v_camp_id INT;
    v_request_id INT;
    v_process_id INT;
    v_last_donation DATE;
BEGIN
    -- Debug: Log input
    RAISE NOTICE 'Processing donation for user %, date %', NEW.user_id, NEW.donation_date;

    -- Check for recent donation
    SELECT MAX(donation_date) INTO v_last_donation
    FROM donates
    WHERE user_id = NEW.user_id;
    RAISE NOTICE 'Last donation for user %: %', NEW.user_id, v_last_donation;

    IF v_last_donation IS NOT NULL THEN
        IF NEW.donation_date = v_last_donation THEN
            RAISE EXCEPTION 'User % cannot donate multiple times on the same day: %', NEW.user_id, NEW.donation_date;
        END IF;
        IF NEW.donation_date < v_last_donation + INTERVAL '60 days' THEN
            RAISE EXCEPTION 'User % cannot donate within 60 days of last donation on %', NEW.user_id, v_last_donation;
        END IF;
    END IF;

    -- Get user's blood type and city_id
    SELECT blood_type, city_id INTO v_blood_type, v_city_id
    FROM users
    WHERE user_id = NEW.user_id;
    IF NOT FOUND THEN
        RAISE EXCEPTION 'User % not found', NEW.user_id;
    END IF;

    -- Find an active camp
    SELECT camp_id INTO v_camp_id
    FROM camp
    WHERE city_id = v_city_id
    AND start_date <= NEW.donation_date
    AND end_date >= NEW.donation_date
    LIMIT 1;
    IF v_camp_id IS NULL THEN
        RAISE EXCEPTION 'No active camp available in city % on %', v_city_id, NEW.donation_date;
    END IF;

    -- Insert into inventory
    INSERT INTO inventory (camp_id, blood_type, expiry_date, assigned)
    VALUES (v_camp_id, v_blood_type, NEW.donation_date + INTERVAL '42 days', 'no')
    RETURNING blood_id INTO NEW.blood_id;

    -- Update donates
    UPDATE donates
    SET blood_id = NEW.blood_id
    WHERE user_id = NEW.user_id
    AND donation_date = NEW.donation_date
   ;

    -- Find a matching pending request
   

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS donation_trigger ON donates;
CREATE TRIGGER donation_trigger
before INSERT ON donates
FOR EACH ROW
EXECUTE FUNCTION handle_donation_inventory();
select * from employees

--trigger which checks for expiry blood everyday and updates the inventory with exipry blood id assigned as 'ex'
-- Drop existing function and trigger if they exist
DROP FUNCTION IF EXISTS update_expired_blood();
DROP TRIGGER IF EXISTS after_expiry_update ON inventory;
DROP FUNCTION IF EXISTS log_expiry_update();

-- Create function to update expired blood
CREATE OR REPLACE FUNCTION update_expired_blood()
RETURNS VOID AS $$
DECLARE
    v_updated_count INTEGER;
BEGIN
    -- Update inventory where blood is expired
    UPDATE inventory
    SET assigned = 'ex'
    WHERE expiry_date <= CURRENT_DATE
    AND assigned != 'ex'; -- Avoid redundant updates

    GET DIAGNOSTICS v_updated_count = ROW_COUNT;
    
    -- Log updates
    RAISE NOTICE 'Updated % blood units to assigned=''ex'' on %', v_updated_count, CURRENT_DATE;
END;
$$ LANGUAGE plpgsql;

-- Create function for trigger to log changes
CREATE OR REPLACE FUNCTION log_expiry_update()
RETURNS TRIGGER AS $$
BEGIN
    RAISE NOTICE 'Blood ID % updated to assigned=''ex'' on %', NEW.blood_id, CURRENT_DATE;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create trigger to log updates
CREATE TRIGGER after_expiry_update
AFTER UPDATE OF assigned ON inventory
FOR EACH ROW
WHEN (OLD.assigned != 'ex' AND NEW.assigned = 'ex')
EXECUTE FUNCTION log_expiry_update();

--functions
-- Create or replace admin_add_city function
CREATE OR REPLACE FUNCTION admin_add_city(p_city_name VARCHAR, p_longitude DOUBLE PRECISION, p_latitude DOUBLE PRECISION)
RETURNS INTEGER AS $$
DECLARE
    v_city_id INTEGER;
BEGIN
    -- Insert new city with name and location as POINT
    INSERT INTO city (name, location)
    VALUES (p_city_name, POINT(p_longitude, p_latitude))
    RETURNING city_id INTO v_city_id;

    RETURN v_city_id;

EXCEPTION
    WHEN unique_violation THEN
        RAISE EXCEPTION 'City name % already exists', p_city_name;
    WHEN check_violation THEN
        RAISE EXCEPTION 'Invalid location coordinates: longitude must be -180 to 180, latitude must be -90 to 90';
    WHEN OTHERS THEN
        RAISE EXCEPTION 'Error adding city: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;

-- Create or replace user_add_donation function
CREATE OR REPLACE FUNCTION user_view_details(p_user_id INTEGER)
RETURNS JSONB AS $$
DECLARE
    v_result JSONB;
BEGIN
    SELECT jsonb_build_object(
        'user_id', u.user_id,
        'name', u.name,
        'blood_type', u.blood_type,
        'city_name', COALESCE(c.name, 'Unknown'),
        'dob', u.dob,
        'contact', u.contact,
        'donations', COALESCE(
            (SELECT jsonb_agg(
                jsonb_build_object(
                    'blood_id', d.blood_id,
                    'donation_date', d.donation_date,
                    'camp_city', c2.name
                )
            )
            FROM donates d
            LEFT JOIN inventory i ON d.blood_id = i.blood_id
            LEFT JOIN camp ca ON i.camp_id = ca.camp_id
            LEFT JOIN city c2 ON ca.city_id = c2.city_id
            WHERE d.user_id = p_user_id),
            '[]'::jsonb
        ),
        'requests', COALESCE(
            (SELECT jsonb_agg(
                jsonb_build_object(
                    'request_id', r.request_id,
                    'blood_type', r.blood_type,
                    'units_required', r.units_required,
                    'request_date', r.request_date,
                    'status', COALESCE(rs.status, 'Pending'),
                    'blood_found', COALESCE(rs.blood_found, 'No')
                )
            )
            FROM requests r
            LEFT JOIN request_status rs ON r.request_id = rs.request_id
            WHERE r.user_id = p_user_id),
            '[]'::jsonb
        )
    ) INTO v_result
    FROM users u
    LEFT JOIN city c ON u.city_id = c.city_id
    WHERE u.user_id = p_user_id;

    IF v_result IS NULL THEN
        RAISE EXCEPTION 'User ID % not found', p_user_id;
    END IF;

    RETURN v_result;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'Error fetching user details: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;
-- Create or replace coordinator_add_camp function
CREATE OR REPLACE FUNCTION coordinator_add_camp(p_city_id INTEGER, p_start_date DATE, p_end_date DATE)
RETURNS INTEGER AS $$
DECLARE
    v_camp_id INTEGER;
BEGIN
    IF p_end_date <= p_start_date THEN
        RAISE EXCEPTION 'End date must be after start date';
    END IF;

    IF NOT EXISTS (SELECT 1 FROM city WHERE city_id = p_city_id) THEN
        RAISE EXCEPTION 'City ID % does not exist', p_city_id;
    END IF;

    INSERT INTO camp (city_id, start_date, end_date)
    VALUES (p_city_id, p_start_date, p_end_date)
    RETURNING camp_id INTO v_camp_id;

    RETURN v_camp_id;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'Error adding camp: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;

-- Create or replace registrar_add_request function
CREATE OR REPLACE FUNCTION registrar_add_request(p_user_id INTEGER, p_employee_id INTEGER, p_blood_type VARCHAR(3), p_units_required INTEGER, p_request_date DATE)
RETURNS INTEGER AS $$
DECLARE
    v_request_id INTEGER;
BEGIN
    IF p_units_required <= 0 THEN
        RAISE EXCEPTION 'Units required must be positive';
    END IF;

    IF p_blood_type NOT IN ('A+', 'A-', 'B+', 'B-', 'AB+', 'AB-', 'O+', 'O-') THEN
        RAISE EXCEPTION 'Invalid blood type: %', p_blood_type;
    END IF;

    INSERT INTO requests (user_id, employee_id, units_required, blood_type, request_date)
    VALUES (p_user_id, p_employee_id, p_units_required, p_blood_type, p_request_date)
    RETURNING request_id INTO v_request_id;

    RETURN v_request_id;

EXCEPTION
    WHEN foreign_key_violation THEN
        RAISE EXCEPTION 'Invalid user ID or employee ID';
    WHEN OTHERS THEN
        RAISE EXCEPTION 'Error adding request: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;


This is the function based on approval or rejection 
CREATE OR REPLACE FUNCTION process_blood_request(
    p_process_id INT,
    p_action VARCHAR
) RETURNS VOID AS $$
DECLARE
    v_blood_id INT;
    v_status VARCHAR;
    v_blood_found VARCHAR;
BEGIN
    SELECT blood_id INTO v_blood_id
    FROM request_status
    WHERE process_id = p_process_id
    FOR UPDATE;

    IF v_blood_id IS NULL THEN
        RAISE EXCEPTION 'No blood assigned to process_id %', p_process_id;
    END IF;

    IF p_action = 'approve' THEN
        v_status := 'yes';
        v_blood_found := 'yes';
        UPDATE inventory
        SET assigned = 'yes'
        WHERE blood_id = v_blood_id;
        UPDATE request_status
        SET status = v_status,
            blood_found = v_blood_found,
            date_approved = CURRENT_DATE
        WHERE process_id = p_process_id;
    ELSIF p_action = 'reject' THEN
        v_status := 'yes';
        v_blood_found := 'no';
        UPDATE inventory
        SET assigned = 'no'
        WHERE blood_id = v_blood_id;
        UPDATE request_status
        SET blood_id = NULL,
            status = v_status,
            blood_found = v_blood_found,
            date_approved = CURRENT_DATE
        WHERE process_id = p_process_id;
    ELSE
        RAISE EXCEPTION 'Invalid action: %. Must be ''approve'' or ''reject''.', p_action;
    END IF;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION process_blood_request(
    p_process_id INT,
    p_action VARCHAR
) RETURNS VOID AS $$
DECLARE
    v_blood_id INT;
    v_status VARCHAR;
    v_blood_found VARCHAR;
BEGIN
    SELECT blood_id INTO v_blood_id
    FROM request_status
    WHERE process_id = p_process_id
    FOR UPDATE;

    IF v_blood_id IS NULL THEN
        RAISE EXCEPTION 'No blood assigned to process_id %', p_process_id;
    END IF;

    IF p_action = 'approve' THEN
        v_status := 'yes';
        v_blood_found := 'yes';
        UPDATE inventory
        SET assigned = 'yes'
        WHERE blood_id = v_blood_id;
        UPDATE request_status
        SET status = v_status,
            blood_found = v_blood_found,
            date_approved = CURRENT_DATE
        WHERE process_id = p_process_id;
    ELSIF p_action = 'reject' THEN
        v_status := 'yes';
        v_blood_found := 'no';
        UPDATE inventory
        SET assigned = 'no'
        WHERE blood_id = v_blood_id;
        UPDATE request_status
        SET blood_id = NULL,
            status = v_status,
            blood_found = v_blood_found,
            date_approved = CURRENT_DATE
        WHERE process_id = p_process_id;
    ELSE
        RAISE EXCEPTION 'Invalid action: %. Must be ''approve'' or ''reject''.', p_action;
    END IF;
END;
$$ LANGUAGE plpgsql;




--roles
create role users login password 'test123'
create view	personal_details as(
select * from users
)
create view donation_history as(
select * from donates
)
create view request_history as(
select r.user_id,r.request_id,rs.status,rs.date_approved from requests r
,request_status rs where r.request_id=rs.request_id
)
grant select on personal_details to users
grant select on donation_history to users
grant select on request_history to users
create role employee_registrar with login password 'test123'
create view inventory_view as(
select * from inventory
)
create view donation_view as(
select u.user_id,u.name,d.blood_id,u.blood_type,d.donation_date,u.city_id
from users u join donates d on d.user_id=u.user_id)
create view blood_requests as(
select r.request_id,r.user_id,u.name,r.employee_id,u.blood_type,r.units_required
from requests r join users u on r.user_id=u.user_id
)
create view requeststatus as (
select * from request_status)
grant all on requests,request_status to employee_registrar
grant select on inventory_view to employee_registrar
grant select on donation_view to employee_registrar
grant select on blood_requests to employee_registrar
grant select on requeststatus to employee_registrar
create role camp_cordinator login password 'test123'
create view camps as (
select camp_id,start_date,end_date from camp
)
create view blood_inventory as (
select blood_type,expiry_date,camp_id from inventory)

grant all on camp,inventory,request_status to camp_cordinator
grant select on camps to camp_cordinator
grant select on blood_inventory to camp_cordinator


CREATE INDEX idx_inventory ON inventory (blood_type, expiry_date); 
CREATE INDEX idx_request ON requests using hash(request_id);
create index idx_users on users using hash(user_id);

